// Generated by CoffeeScript 2.5.1
(function() {
  var Callbacks, Yma, hash, hashObject, ogid;

  ogid = function(radix, rnd) {
    return parseInt((new Date().valueOf() - new Date(2020, 0, 1).valueOf()).toString().concat(Math.floor(Math.random() * (9999 || rnd))).split('').reverse().join('')).toString(radix || 36);
  };

  hash = function(str) {
    var h, i;
    if (typeof str === 'undefined') {
      return 0;
    }
    h = 5381;
    i = str.length;
    while (i) {
      h = (h * 33) ^ str.charCodeAt(--i);
    }
    return h;
  };

  hashObject = function(obj) {
    var hashed, key, val;
    hashed = {};
    for (key in obj) {
      val = obj[key];
      if (/^\$/.test(key)) {
        continue;
      }
      hashed[key] = hash(JSON.stringify(val));
    }
    return hashed;
  };

  Callbacks = function() {
    var callbacks;
    callbacks = {};
    return {
      $on: function(name, fn) {
        callbacks[name] = callbacks[name] || [];
        return callbacks[name].push(fn);
      },
      $off: function(name, fn) {
        callbacks[name] = callbacks[name] || [];
        return callbacks[name].splice(callbacks[name].indexOf(fn), 1);
      },
      $call: async function(name, data) {
        var fn, j, len, ref, results;
        if (callbacks[name]) {
          ref = callbacks[name];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            fn = ref[j];
            results.push((await fn(data)));
          }
          return results;
        }
      }
    };
  };

  Yma = function(appName) {
    var Scope, bootstrapped, callbacks, checkAttrs, components, elements, evalInContext, fillTemplate, fillVars, getProps, makeId, mergeScopes, preRender, preRenderChildren, render, renderChildren, rootElem, scopes, services, teardown, teardownChildren, updateScopes;
    rootElem = null;
    makeId = function(node, root) {
      var id, mynode;
      root = root || rootElem;
      if (node === root) {
        return 'root';
      }
      id = '';
      while (node !== root) {
        id += node.tagName + ':';
        mynode = node;
        while (mynode.previousSibling) {
          id += mynode.tagName + '@';
          mynode = mynode.previousSibling;
        }
        node = node.parentNode;
      }
      return id;
    };
    evalInContext = function(str, context) {
      try {
        return (new Function(`with(this) {return ${str}}`)).call(context);
      } catch (error) {}
    };
    fillTemplate = function(template, scope) {
      return template.replace(/\{\{(.+?)\}\}/g, function(all, expression) {
        return evalInContext(expression, scope) || '';
      });
    };
    components = {};
    elements = [];
    scopes = {};
    services = {};
    callbacks = Callbacks();
    bootstrapped = false;
    mergeScopes = function(scope, merge) {
      var key, results, val;
      results = [];
      for (key in merge) {
        val = merge[key];
        if (!/^\$/.test(key)) {
          results.push(scope[key] = val);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    updateScopes = async function() {
      var id, ref, ref1, results, scope, scopeElems;
      results = [];
      for (id in scopes) {
        scope = scopes[id];
        scopeElems = elements.filter(function(element) {
          return element.scope === id;
        });
        if (scopeElems.length === 0) {
          if ((ref = scope.$parent) != null) {
            ref.$children.splice((ref1 = scope.$parent) != null ? ref1.$children.indexOf(id) : void 0, 1);
          }
          await scope.$call('teardown');
          //remove scope from any services
          results.push(delete scopes[scope.$id]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    teardown = async function(id) {
      var r;
      r = new RegExp(id + '$');
      elements = elements.filter(function(element) {
        return !r.test(element.id);
      });
      return (await updateScopes());
    };
    teardownChildren = async function(id) {
      var r;
      r = new RegExp('.+' + id + '$');
      elements = elements.filter(function(element) {
        return !r.test(element.id);
      });
      return (await updateScopes());
    };
    Scope = function(merge) {
      var intervals, newscope, scopeCallbacks, timeouts;
      scopeCallbacks = Callbacks();
      timeouts = [];
      intervals = [];
      newscope = {
        $id: ogid(),
        $children: [],
        $parent: null,
        $update: async function(updates, hard) {
          var elemId, element, elemsToUpdate, i, index, j, key, len, myscope, preElements, preRoot, realRoot, ref, reset, scope, sharedWithParent, unknowns, updateScope, updatedScopes;
          myscope = this;
          while (myscope.$parent) {
            for (key in updates) {
              if (typeof myscope[key] !== 'undefined') {
                sharedWithParent = myscope[key] === ((ref = myscope.$parent) != null ? ref[key] : void 0);
                myscope[key] = updates[key];
                if (!sharedWithParent) {
                  delete updates[key];
                }
              } else {
                delete updates[key];
              }
            }
            myscope = myscope.$parent;
          }
          updatedScopes = Object.values(scopes).filter(function(scope) {
            return JSON.stringify(scope.$hash) !== JSON.stringify(hashObject(scope));
          });
          index = 0;
          while (updatedScopes.length > index + 1) {
            i = updatedScopes.length;
            while (i-- > index) {
              if (updatedScopes[i].$isDescendantOf(updatedScopes[0])) {
                updatedScopes.splice(i, 1);
                continue;
              }
              if (updatedScopes[i].$isAncestorOf(updatedScopes[0])) {
                updatedScopes[0] = updatedScopes[i];
                updatedScopes.splice(i, 1);
                continue;
              }
            }
            index++;
          }
          updateScope = function(scope, changedVars) {
            var childScope, j, len, myhash, ref1, ref2, results, val;
            myhash = hashObject(scope);
            for (key in myhash) {
              val = myhash[key];
              if (val !== ((ref1 = scope.$hash) != null ? ref1[key] : void 0)) {
                if (typeof changedVars[key] !== 'undefined') {
                  changedVars[key] = scope[key];
                }
              } else {
                if (typeof changedVars[key] !== 'undefined') {
                  scope[key] = changedVars[key];
                }
              }
            }
            scope.$hash = myhash;
            ref2 = scope.$children;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              childScope = ref2[j];
              results.push(updateScope(childScope, changedVars));
            }
            return results;
          };
          preRoot = document.createElement('div');
          preElements = [];
          realRoot = elements[0];
          preRoot.innerHTML = realRoot.html;
          await preRender(preRoot, preRoot, 0, preElements);
          unknowns = preElements.filter(function(element) {
            return /^UNKNOWN@/.test(element.id);
          });
          elemsToUpdate = [];
          unknowns.forEach(function(unknown) {
            var parentId;
            parentId = unknown.id.replace(/UNKNOWN@\w+:[\w@]+@/, '');
            if (!elemsToUpdate.includes(parentId)) {
              return elemsToUpdate.push(parentId);
            }
          });
          for (j = 0, len = elemsToUpdate.length; j < len; j++) {
            elemId = elemsToUpdate[j];
            element = elements.filter(function(element) {
              return element.id === elemId;
            })[0];
            if (element) {
              scope = scopes[element.scope];
              await teardownChildren(elemId);
              element.elem.innerHTML = element.html;
              await renderChildren(element.elem, scope);
            }
          }
          reset = function(scope) {
            var childScope, elem, elemsToReset, k, l, len1, len2, len3, m, name, node, ref1, ref2, ref3, results, t, val;
            elemsToReset = elements.filter(function(element) {
              return element.scope === scope.$id;
            });
            for (k = 0, len1 = elemsToReset.length; k < len1; k++) {
              elem = elemsToReset[k];
              t = 0;
              ref1 = elem.elem.childNodes;
              for (l = 0, len2 = ref1.length; l < len2; l++) {
                node = ref1[l];
                if (node.nodeType === document.TEXT_NODE) {
                  node.replaceWith(elem.textNodes[t++] || '');
                }
              }
              ref2 = elem.attributes;
              for (name in ref2) {
                val = ref2[name];
                elem.elem.setAttribute(name, val);
              }
            }
            ref3 = scope.$children;
            results = [];
            for (m = 0, len3 = ref3.length; m < len3; m++) {
              childScope = ref3[m];
              results.push(reset(childScope));
            }
            return results;
          };
          i = updatedScopes.length;
          while (i-- > 0) {
            updateScope(updatedScopes[i], {});
            reset(updatedScopes[i]);
            await updatedScopes[i].$callChildren('update');
          }
          await fillVars();
          await checkAttrs();
          preRoot = null;
        },
        $use: function(name) {
          var component, service;
          if (service = services[name]) {
            this[name] = service.fn;
            service.scopes.push(this.$id);
          } else if (component = components[name.toUpperCase()]) {
            services[name] = {
              fn: (component.service || component)(),
              scopes: [this.$id]
            };
            this[name] = services[name].fn;
          }
          return this.$on('teardown', function() {
            return services[name].scopes.splice(services[name].scopes.indexOf(this.$id), 1);
          });
        },
        $on: scopeCallbacks.$on,
        $off: scopeCallbacks.$off,
        $call: scopeCallbacks.$call,
        $callChildren: async function(name, data) {
          var childScope, j, len, ref;
          await scopeCallbacks.$call(name, data);
          ref = this.$children;
          for (j = 0, len = ref.length; j < len; j++) {
            childScope = ref[j];
            await childScope.$callChildren(name, data);
          }
          return null;
        },
        $isDescendantOf: function(scope) {
          var myscope;
          if (scope.$id === this.$id) {
            return false;
          }
          myscope = this;
          while (myscope.$parent) {
            if (myscope.$id === scope.$id) {
              return true;
            }
            myscope = myscope.$parent;
          }
          return false;
        },
        $isAncestorOf: function(scope) {
          var check;
          if (scope.$id === this.$id) {
            return false;
          }
          check = function(myscope) {
            var childScope, j, len, ref;
            if (myscope.$id === scope.$id) {
              return true;
            }
            ref = myscope.$children;
            for (j = 0, len = ref.length; j < len; j++) {
              childScope = ref[j];
              if (check(childScope)) {
                return true;
              }
            }
            return false;
          };
          return check(scope);
        },
        $timeout: function(fn, delay) {
          if (timeouts.length === 0) {
            scopeCallbacks.$on('teardown', function() {
              var j, len, results, timeout;
              results = [];
              for (j = 0, len = timeouts.length; j < len; j++) {
                timeout = timeouts[j];
                results.push(window.clearTimeout(timeout));
              }
              return results;
            });
          }
          return timeouts.push(window.setTimeout(fn, delay));
        },
        $interval: function(fn, delay) {
          if (intervals.length === 0) {
            scopeCallbacks.$on('teardown', function() {
              var interval, j, len, results;
              results = [];
              for (j = 0, len = intervals.length; j < len; j++) {
                interval = intervals[j];
                results.push(window.clearTimeout(interval));
              }
              return results;
            });
          }
          return intervals.push(window.setTimeout(fn, delay));
        }
      };
      if (merge && merge.$id) {
        merge.$children.push(newscope);
        newscope.$parent = merge;
      }
      mergeScopes(newscope, merge);
      return newscope;
    };
    getProps = function(elem) {
      var myattrs;
      myattrs = {};
      elem.getAttributeNames().forEach(function(name) {
        return myattrs[name] = elem.getAttribute(name);
      });
      return myattrs;
    };
    renderChildren = async function(elem, scope) {
      var child, children, j, k, len, len1, ref, results;
      children = [];
      ref = elem.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        children.push(child);
      }
      results = [];
      for (k = 0, len1 = children.length; k < len1; k++) {
        child = children[k];
        results.push((await render(child, scope)));
      }
      return results;
    };
    render = async function(elem, scope) {
      var attr, attrComponent, attributes, clone, component, html, i, j, k, len, len1, myscopes, newscope, node, preId, ref, ref1, textNodes;
      preId = null;
      scopes[scope.$id] = scope;
      scope.$hash = hashObject(scope);
      scope.$call('bootstrap');
      html = elem.innerHTML;
      textNodes = [];
      attributes = {};
      ref = elem.childNodes;
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        if (node.nodeType === document.TEXT_NODE) {
          textNodes.push(node.data);
        }
      }
      ref1 = elem.getAttributeNames();
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        attr = ref1[k];
        attributes[attr] = elem.getAttribute(attr);
        if (attrComponent = components[attr.toUpperCase()]) {
          if (typeof attrComponent.pre === 'function') {
            myscopes = (await attrComponent.pre(scope, elem, getProps(elem)));
          }
          if (typeof myscopes !== 'undefined') {
            elem.removeAttribute(attr);
            preId = 'PREX:' + makeId(elem);
            if (myscopes) {
              if (myscopes.length) {
                i = myscopes.length;
                while (i-- > 0) {
                  clone = elem.cloneNode();
                  clone.innerHTML = elem.innerHTML;
                  elem.parentNode.insertBefore(clone, elem.nextSibling);
                  render(clone, myscopes[i]);
                }
                elem.parentNode.removeChild(elem);
              } else {
                if (myscopes.length === 0) {
                  elem.parentNode.removeChild(elem);
                }
              }
            }
          }
          //return#check this
          elem.setAttribute('checkattrs', true);
        }
      }
      if (component = components[elem.tagName]) {
        newscope = Scope(scope);
        scope = newscope;
        scopes[scope.$id] = scope;
        if (component.controller) {
          component.controller(scope, elem);
        }
        scope.$hash = hashObject(scope);
        elem.innerHTML = component.template ? component.template : html;
        elem.innerHTML = elem.innerHTML.replace('<children></children>', html);
      }
      elements.push({
        id: preId || makeId(elem),
        elem: elem,
        scope: scope.$id,
        html: html,
        textNodes: textNodes,
        attributes: attributes
      });
      return (await renderChildren(elem, scope));
    };
    preRenderChildren = async function(elem, root, preElements) {
      var child, children, j, k, len, len1, ref, results;
      children = [];
      ref = elem.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        children.push(child);
      }
      results = [];
      for (k = 0, len1 = children.length; k < len1; k++) {
        child = children[k];
        results.push((await preRender(child, root, 0, preElements)));
      }
      return results;
    };
    preRender = async function(elem, root, index, preElements) {
      var attr, attrComponent, attributes, clone, component, html, i, id, j, len, myscopes, preId, realElem, ref, scope;
      id = makeId(elem, root);
      preId = 'PREX:' + id;
      html = elem.innerHTML;
      attributes = {};
      //get scope using id
      realElem = elements.filter(function(myelem) {
        return (myelem.id === id) || (myelem.id === preId);
      })[index];
      scope = scopes[realElem != null ? realElem.scope : void 0];
      if (!(realElem || scope)) {
        preElements.push({
          id: 'UNKNOWN@' + id
        });
        return;
      }
      ref = elem.getAttributeNames();
      //get .pre scopes
      for (j = 0, len = ref.length; j < len; j++) {
        attr = ref[j];
        attributes[attr] = elem.getAttribute(attr);
        if (attrComponent = components[attr.toUpperCase()]) {
          if (typeof attrComponent.pre === 'function') {
            myscopes = (await attrComponent.pre(scope, elem, getProps(elem)));
          }
          if (typeof myscopes !== 'undefined') {
            if (myscopes) {
              if (myscopes.length) {
                i = myscopes.length;
                while (i-- > 0) {
                  myscopes[i].$parent.$children.splice(myscopes[i].$parent.$children.indexOf(myscopes[i], 1));
                  clone = elem.cloneNode();
                  clone.innerHTML = elem.innerHTML;
                  clone.removeAttribute(attr);
                  elem.parentNode.insertBefore(clone, elem.nextSibling);
                  await preRender(clone, root, i - 1, preElements);
                }
                elem.parentNode.removeChild(elem);
              } else {
                if (myscopes.length === 0) {
                  preElements.push({
                    id: 'UNKNOWN@H1:H1@' + makeId(elem.parentNode, root)
                  });
                  elem.parentNode.removeChild(elem);
                  return;
                }
              }
            }
          }
        }
      }
      //  preRender pre stuff
      //get component
      if (component = components[elem.tagName]) {
        elem.innerHTML = component.template ? component.template : html;
        elem.innerHTML = elem.innerHTML.replace('<children></children>', html);
      }
      //render component
      //push to preElements
      preElements.push({
        id: id
      });
      //preRenderChildren
      return (await preRenderChildren(elem, root, preElements));
    };
    fillVars = function() {
      var i, j, len, name, node, ref, results, val;
      i = elements.length;
      results = [];
      while (i-- > 0) {
        ref = elements[i].elem.childNodes;
        for (j = 0, len = ref.length; j < len; j++) {
          node = ref[j];
          if (node.nodeType === document.TEXT_NODE && /\{\{/.test(node.data)) {
            node.replaceWith(fillTemplate(node.data, scopes[elements[i].scope]));
          }
        }
        results.push((function() {
          var k, len1, ref1, results1;
          ref1 = elements[i].elem.getAttributeNames();
          results1 = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            name = ref1[k];
            if (/\{\{/.test((val = elements[i].elem.getAttribute(name)))) {
              results1.push(elements[i].elem.setAttribute(name, fillTemplate(val, scopes[elements[i].scope])));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    };
    checkAttrs = function() {
      var attr, attrComponent, attrFn, elem, j, len, results;
      results = [];
      for (j = 0, len = elements.length; j < len; j++) {
        elem = elements[j];
        if (elem.elem.getAttribute('checkattrs')) {
          elem.elem.removeAttribute('checkattrs');
          results.push((function() {
            var k, len1, ref, results1;
            ref = elem.elem.getAttributeNames();
            results1 = [];
            for (k = 0, len1 = ref.length; k < len1; k++) {
              attr = ref[k];
              if (attrComponent = components[attr.toUpperCase()]) {
                attrFn = attrComponent.post || attrComponent;
                if (typeof attrFn === 'function') {
                  attrFn(scopes[elem.scope], elem.elem, getProps(elem.elem));
                }
                results1.push(elem.elem.removeAttribute(attr));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          })());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    return {
      render: async function(elem, scope) {
        if (!bootstrapped) {
          await callbacks.$call('bootstrap');
          bootstrapped = true;
        }
        elem = elem || document.querySelector('[app=' + appName + ']');
        rootElem = rootElem || elem;
        scope = scope || Scope();
        await render(elem, scope);
        await fillVars();
        await checkAttrs();
        return callbacks.$call('rendered');
      },
      $renderChildren: async function(elem, scope) {
        await renderChildren(elem, scope);
        await fillVars();
        await checkAttrs();
        return callbacks.$call('rendered');
      },
      component: function(nameOrObj, fn) {
        var name;
        if (typeof nameOrObj === 'object') {
          for (name in nameOrObj) {
            fn = nameOrObj[name];
            components[name.toUpperCase()] = fn(this);
          }
        } else {
          components[nameOrObj.toUpperCase()] = fn(this);
        }
        return this;
      },
      Scope: Scope,
      Callbacks: Callbacks,
      $getComponents: function() {
        return components;
      },
      $getElements: function() {
        return elements;
      },
      $getServices: function() {
        return services;
      },
      $getScopes: function() {
        return scopes;
      },
      $eval: evalInContext,
      $getProps: getProps,
      $teardown: teardown,
      $teardownChildren: teardownChildren,
      $on: callbacks.$on,
      $off: callbacks.$off,
      $hash: hash,
      $hashObject: hashObject,
      $makeId: makeId,
      $getService: function(name) {
        var component, service;
        if (service = services[name]) {
          return service.fn;
        } else if (component = components[name.toUpperCase()]) {
          services[name] = {
            fn: (component.service || component)(),
            scopes: []
          };
          return services[name].fn;
        }
        return null;
      },
      $addClass: function(elem, classNames) {
        var className, j, len;
        if (typeof classNames === 'string') {
          classNames = [classNames];
        }
        for (j = 0, len = classNames.length; j < len; j++) {
          className = classNames[j];
          this.$removeClass(elem, className);
          elem.className += ' ' + className;
        }
        return null;
      },
      $removeClass: function(elem, classNames) {
        var className, j, len, r;
        if (typeof classNames === 'string') {
          classNames = [classNames];
        }
        for (j = 0, len = classNames.length; j < len; j++) {
          className = classNames[j];
          r = new RegExp('\\s*\\b' + className + '\\b', 'g');
          elem.className = elem.className.replace(r, '');
        }
        return null;
      }
    };
  };

  module.exports = Yma;

}).call(this);

//# sourceMappingURL=main.js.map
